#!/bin/sh -e

help() {
	cat - >&2 <<EOF
plauncher - POSIX launcher script

plauncher [supervisor_command [args...]]

plauncher will query a command from the user and run the command. A
history of commands will be shown to the user to select from, or the
user may type in a new command which will be ran and added to the
history.

Arguments provided to plauncher will be interpreted as a "supervisor
command" to run the user's selected command with (i.e. plauncher i3-msg
exec, plauncher swaymsg exec). The supervisor command as an argument will
be given the user's selected command as a single argument instead of
word-splitting the user's command.

plauncher's user interface is basic, use Tab or ^P to traverse backward
through the command history, use ^N to traverse forward through the
command history, and most everything else will be interpreted as a query
to search through the command history. ^W is also available for deleting
words and BACKSPACE for deleting characters. Other line editing is not
implemented, since the idea is to type short commands and then never
type them again.

You must set the \$TERMCMD environment variable, something like "xterm
-e", so applications may be launched in your terminal of choice.
EOF
}

getch() { dd bs=1 count=1 2> /dev/null ; }
cleanterm() { stty sane; printf '\n'; }

write_history() {
	if [ "$anonymous" ]; then
		return 0
	else
		deduped=$(grep -Fxve "$*" -e "$2" < "$PLAUNCHER_HISTORY" || :)
		cat > "$PLAUNCHER_HISTORY" <<-EOF
			$deduped
			$*
		EOF
	fi
}

export POSIXLY_CORRECT=1

case "$1" in
	--help|-h) help; exit 0;;
	*) ;;
esac

: "${TERMCMD:?'$TERMCMD must be set (i.e. xterm -e)'}"

# you can use showkey -a to figure out the octal value for a key
KEY_BACKSPACE=$(printf '\177')
KEY_CTRL_U=$(printf '\025')
KEY_CTRL_W=$(printf '\027')
KEY_CTRL_P=$(printf '\020')
KEY_CTRL_N=$(printf '\016')
KEY_ESCAPE=$(printf '\033')
KEY_TAB=$(printf '\t')
EL=$(printf '\033[K')
ED=$(printf '\033[J')
CP=$(printf '\033[H')
NL="
"

# ensure $PLAUNCHER_HISTORY is set and the file exists
: >> "${PLAUNCHER_HISTORY:="${HOME:?}/.plauncher"}"
history_cache=$(cat "$PLAUNCHER_HISTORY")

stty -icanon -echo -nl
unset -v cmd cursor list_length appended
while :; do
	if [ "$cursor" ]; then
		cmd=$(sed -n "${cursor}p") <<-EOF
			$list
		EOF

		# handle the command context (background/terminal) number if available
		case "${cmd%% *}" in [0-9])
			cmd_ctx="${cmd%% *}"
			cmd="${cmd#[0-9] }"
		esac

		printf "\r> %s$ED" "$cmd" >&2
	elif [ ! "$list" ] && [ "$appended" ]; then
		printf '%s' "$c"
	else
		list=$(grep -Fie "$cmd" || :) <<-EOF
			$history_cache
		EOF
		visual_list=$(sed "s/$/$EL/g ; s/^[0-9] //g") <<-EOF
			$list
		EOF

		printf "$CP%s" "${list:+${visual_list}${NL}}" >&2
		printf "\r> %s$ED" "$cmd" >&2
	fi

	c=$(getch)
	[ "$c" ] || break
	case "$c" in
		"$KEY_ESCAPE")
			cleanterm
			exit 0
			;;
		"$KEY_CTRL_P"|"$KEY_TAB")
			if [ "$cursor" ]; then
				if [ "$cursor" -gt 1 ]; then
					cursor=$((cursor - 1))
				fi
			else
				list_length=$(wc -l) <<-EOF
					$list
				EOF
				cursor="$list_length"
			fi
			;;
		"$KEY_CTRL_N")
			if [ "$cursor" ] && [ "$cursor" -lt "$list_length" ]; then
				cursor=$((cursor + 1))
			else # reached end of history
				unset -v cmd cursor list_length appended
			fi
			;;
		"$KEY_CTRL_U") # clear line
			unset -v cmd cursor list_length appended
			;;
		"$KEY_CTRL_W") # delete last word from line
			# XXX: this deletes words awkwardly compared to other
			# programs
			cmd=$(sed 's/[ ]*[^ ]*$//') <<-EOF
				$cmd
			EOF
			unset -v cursor list_length appended
			;;
		"$KEY_BACKSPACE")
			cmd=${cmd%?}
			unset -v cursor list_length appended
			;;
		*)
			# only append characters to the command if they aren't
			# whacky characters
			cval=$(od -A n -N 1 -t u1) <<-EOF
				$c
			EOF
			if [ "$cval" -ge 32 ]; then
				cmd="${cmd}${c}"
				appended=1
				unset -v cursor list_length
			fi
			;;
	esac
done

case "$cmd" in
	' '*) anonymous=1 ;;
	'') exit 0 ;;
	*) unset -v anonymous ;;
esac

if [ ! "$cmd_ctx" ]; then
	printf '\n'
	printf '%s\n' "How should $cmd be ran?" \
		'[1] terminal' \
		'[2] background (default)' >&2
	cmd_ctx=$(getch)
fi

cleanterm

case "$cmd_ctx" in
	1) terminal=1 ;;
	*) unset -v terminal; cmd_ctx=2 ;;
esac

write_history "$cmd_ctx" "$cmd"

if [ "$*" ]; then
	POSIXLY_CORRECT="" exec "$@" "${terminal:+$TERMCMD }$cmd"
else
	eval POSIXLY_CORRECT="" exec "${terminal:+$TERMCMD }$cmd"
fi

