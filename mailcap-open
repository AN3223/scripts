#!/bin/sh -ef
# This is a file opener that uses the mailcap file for configuration and
# shares (mostly) the same CLI as xdg-open:
#
# mailcap-open [file | URL]
#
# ...and the heavy lifting is done by the mailcap file(s) (see MAILCAPS
# below). If the file is omitted or - then the standard input will be
# read instead.
#
# IMPORTANT: Occurrences of %s must be double quoted (or unquoted if you
# want word-splitting) in your mailcap files. This is because it is
# actually substituted for a shell variable, not a filename. This is
# done on purpose to avoid issues with special characters.
# So don't single quote %s! It will cause errors! You have been warned!
# Also don't forget to set the TERMCMD environment variable, see below.
#
# The following environment variables are used:
#
# TERMCMD
#   The prefix command for spawning programs in a terminal, i.e. xterm
#   -e for xterm. There is no default, this MUST be set if mailcap-open
#   isn't being spawned from a terminal.
#
# MAILCAPS
#   The colon-delimited mailcap search path defined in RFC 1524,
#   defaults to:
#   ~/.mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap
#
# MIMER
#   The command used to get the mimetype of a file, defaults to:
#   xdg-mime query filetype
#
# MCO_NEEDSTERMINAL
#   If set, mailcap-open will always act like needsterminal is set.
#   Useful for preventing mailcap-open from opening the file in the
#   background.
#
# MCO_DOWNLOADER
#   The command used to download URLs if MCO_HANDLER is unset, defaults to
#   curl
#
# MCO_HANDLER
#   A command that may override the handling of the file mailcap-open
#   was invoked with (unless the file was stdin). A handler will be
#   invoked like so:
#
#   handler {file | URL}
#
#   If MCO_HANDLER exits with an error code then mailcap-open will
#   assume the handler has already opened the file and mailcap-open will
#   do an early exit (never interpreting the mailcap file).
#
#   If MCO_HANDLER exits successfully then the mailcap will be
#   interpreted as normal.
#
#   If MCO_HANDLER is unset then mailcap-open will default to using
#   MCO_DOWNLOADER to handle URLs, and use the mailcap file for handling
#   normal files.
#
#   Ideally a custom handler should always throw an error in the case of
#   a URL.
#

FILENAME=${1:-'-'}
MCO_DOWNLOADER=${MCO_DOWNLOADER:-curl}

# FIXME tmp won't be deleted after a crash
if [ "$FILENAME" = '-' ]; then
	tmp=$(mktemp)
	cat - > "$tmp"
	FILENAME=$tmp
elif [ "$MCO_HANDLER" ]; then
	$MCO_HANDLER "$FILENAME" || exit
else
	tmp=$(mktemp)
	case "$FILENAME" in
		*://*)
			$MCO_DOWNLOADER "$FILENAME" > "$tmp"
			FILENAME=$tmp
			;;
		*)
			;;
	esac
fi

if [ ! "$MAILCAPS" ]; then
	MAILCAPS="$HOME/.mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"
fi

MAILCAP=$(mktemp)
(
	IFS=:
	for f in $MAILCAPS; do
		cat "$f" >> "$MAILCAP" 2> /dev/null || :
	done
)
if [ ! -s "$MAILCAP" ]; then
	echo 'No mailcap files (or mailcap files are empty)' >&2
	exit 1
fi

MIMER=${MIMER:-xdg-mime query filetype}
MIMETYPE=$($MIMER "$FILENAME")

if [ -t 0 ] && [ -t 1 ]; then
	HASTERMINAL=1
else
	HASTERMINAL=
fi

if [ ! "$HASTERMINAL" ] && [ ! "$TERMCMD" ]; then
	echo 'The TERMCMD environment variable must be set to spawn a terminal
emulator (i.e. xterm -e)' >&2
	exit 1
fi

# Recursively replaces %s and %t
percent_substitute() {
	case "$1" in
		*%t*)
			percent_substitute "${1%%%t*}${FILE_MIMETYPE}${1##*%t}"
			;;
		*%s*)
			percent_substitute "${1%%%s*}"'${FILENAME}'"${1##*%s}"
			;;
		*)
			printf %s "$1"
			return
			;;
	esac
}

# Strips surrounding whitespace from a string
strip_whitespace() {
	string=${1:-$(cat -)}
	string=${string## }
	string=${string%% }
	printf '%s\n' "$string"
}

# Prints the command to run based on the file's mimetype and the
# mimetypes defined in the user's mailcap file. Function is kept in a
# subshell to prevent IFS from leaking out.
select_command() {(
	IFS=';'
	while read -r FILE_MIMETYPE cmd opts; do
		copiousoutput=
		needsterminal=

		# Skip comments
		[ "${FILE_MIMETYPE##\#*}" ] || continue

		# Skip empty lines
		[ "$FILE_MIMETYPE" ] || continue

		FILE_MIMETYPE=$(strip_whitespace "$FILE_MIMETYPE")

		# Skip non-matching mimetypes
		if [ "$FILE_MIMETYPE" = "$MIMETYPE" ]; then
			:
		elif [ "$(dirname "$FILE_MIMETYPE")" = "$(dirname "$MIMETYPE")" ] \
			&& [ "$(basename "$FILE_MIMETYPE")" = '*' ]; then
				:
		else
			continue
		fi

		for opt in $opts; do
			opt=$(strip_whitespace "$opt")
			case "$opt" in
				needsterminal)
					needsterminal=1
					;;
				copiousoutput)
					copiousoutput=1
					;;
				test=*)
					if ! eval "${opt#test=}" > /dev/null 2>&1; then
						next=1
						break
					fi
					;;
				notes=*) ;;
				description=*) ;;
				nametemplate=*) ;;
				x11-bitmap=*) ;;
				compose=*) ;;
				composetyped=*) ;;
				print=*) ;;
				textualnewlines=*) ;;
				x-*) ;;
				*)
					echo "Warning, unrecognized option: $opt" >&2
					;;
			esac
		done

		if [ "$next" ]; then
			next=
			continue
		fi

		[ "$MCO_NEEDSTERMINAL" ] && needsterminal=1

		# The rest of this loop generates shell code in stdout

		[ ! "$needsterminal" ] && printf %s ' ( nohup '

		if [ "$needsterminal" ] && [ ! "$HASTERMINAL" ]; then
			printf %s " $TERMCMD "
		fi

		percent_substitute "$cmd"

		# Prevent unneeded output
		if [ ! "$needsterminal" ] && [ ! "$copiousoutput" ]; then
			printf %s ' > /dev/null 2>&1 '
		fi

		# Put file contents into stdin if %s is unused
		case "$cmd" in *%s*);; *)
			printf %s ' < "$FILENAME" ';;
		esac

		# Implement copiousoutput
		[ "$copiousoutput" ] && printf %s " | ${PAGER:-less} "

		printf %s ' ; rm -f "$tmp" '

		[ ! "$needsterminal" ] && printf %s ' ) & '

		break
	done < "$MAILCAP"
)}

cmd=$(select_command)
if [ "$cmd" ]; then
	eval "$cmd"
else
	rm -f "$tmp"
	exit 1
fi

rm -f "$MAILCAP"
