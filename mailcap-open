#!/bin/sh -ef
# This is a file opener (like xdg-open) that uses the mailcap file for
# configuration. The interface is extremely simple:
# mailcap-open FILE
# ...and the rest is handled by the mailcap file (~/.mailcap-open or
# ~/.mailcap or /etc/ mailcap).

# The following environment variables are used:
#
# MIMER: the command used to get the mimetype of a file, defaults to
# "xdg-mime query filetype"
#
# DOWNLOADER: the command used to download from URLs, defaults to curl
# (expects result to be printed to stdout)
#
# One quirk you should know is that %s is not truly replaced with the
# proper value, but is instead replaced with a variable containing the
# proper value. This is done on purpose to avoid quoting mishaps. So
# when you use %s in your mailcap file you should double quote it like
# this "%s"

# TODO allow the user to configure how URLs are handled

DOWNLOADER=${DOWNLOADER:-curl}
MIMER=${MIMER:-xdg-mime query filetype}

export FILENAME="$1"
case "$FILENAME" in # Handle URLs
	*://*)
		# FIXME tmp won't be deleted after a crash
		tmp=$(mktemp)
		$DOWNLOADER "$FILENAME" > "$tmp"
		FILENAME="$tmp"
		;;
	*)
		;;
esac

if [ ! "$MAILCAPS" ]; then
	MAILCAPS="$HOME/.mailcap:/etc/mailcap:/usr/etc/mailcap:/usr/local/etc/mailcap"
fi

MAILCAP=$(mktemp)
(
	IFS=:
	for f in $MAILCAPS; do
		cat "$f" >> "$MAILCAP" 2> /dev/null || :
	done
)
if [ ! "$(cat "$MAILCAP")" ]; then
	echo 'No mailcap files (or mailcap files are empty)' >&2
	exit 1
fi

MIMETYPE=$($MIMER "$FILENAME")

if [ -t 0 ] && [ -t 1 ]; then
	HASTERMINAL=1
fi

if [ ! "$HASTERMINAL" ] && [ ! "$TERMCMD" ]; then
	echo 'The TERMCMD environment variable must be set to spawn a terminal
emulator (i.e. xterm -e)' >&2
	exit 1
fi

# Recursively replaces %s and %t
percent_substitute() {
		case "$1" in
			*%t*)
				percent_substitute "${1%%%t*}${FILE_MIMETYPE}${1##*%t}"
				;;
			*%s*)
				percent_substitute "${1%%%s*}"'${FILENAME}'"${1##*%s}"
				;;
			*)
				printf %s "$1"
				return
				;;
		esac
}

# Strips surrounding whitespace from a string
strip_whitespace() {
	string=${1:-$(cat -)}
	string=${string## }
	string=${string%% }
	printf '%s\n' "$string"
}

# Prints the command to run based on the file's mimetype and the
# mimetypes defined in the user's mailcap file. Function is kept in a
# subshell to prevent IFS from leaking out.
select_command() {(
	IFS=';'
	while read -r FILE_MIMETYPE cmd opts; do
		copiousoutput=
		needsterminal=

		# Skip comments
		[ "${FILE_MIMETYPE##\#*}" ] || continue

		# Skip empty lines
		[ "$FILE_MIMETYPE" ] || continue

		FILE_MIMETYPE=$(strip_whitespace "$FILE_MIMETYPE")

		# Skip non-matching mimetypes
		if [ "$FILE_MIMETYPE" = "$MIMETYPE" ]; then
			:
		elif [ "$(dirname "$FILE_MIMETYPE")" = "$(dirname "$MIMETYPE")" ] && \
			[ "$(basename "$FILE_MIMETYPE")" = '*' ]; then
				:
		else
			continue
		fi

		for opt in $opts; do
			opt=$(strip_whitespace "$opt")
			case "$opt" in
				needsterminal)
					needsterminal=1
					;;
				copiousoutput)
					copiousoutput=1
					;;
				test=*)
					if ! eval "${opt#test=}"; then
						exit 1 # go to next mimetype
					fi
					;;
				notes=*)
					;;
				description=*)
					;;
				nametemplate=*)
					;;
				x11-bitmap=*)
					;;
				compose=*)
					;;
				composetyped=*)
					;;
				print=*)
					;;
				textualnewlines=*)
					;;
				x-*)
					;;
				*)
					echo "Warning, unrecognized option: $opt" >&2
					;;
			esac
		done || continue

		# The rest of this loop generates shell code in stdout

		[ ! "$needsterminal" ] && printf %s ' ( nohup '

		if [ "$needsterminal" ] && [ ! "$HASTERMINAL" ]; then
			printf %s " $TERMCMD "
		fi

		percent_substitute "$cmd"

		# Prevent unneeded output
		if [ ! "$needsterminal" ] && [ ! "$copiousoutput" ]; then
			printf %s ' > /dev/null 2>&1 '
		fi

		# Put file contents into stdin if %s is unused
		case "$cmd" in *%s*);; *)
			printf %s ' < "$FILENAME" ';;
		esac

		# Implement copiousoutput
		[ "$copiousoutput" ] && printf %s " | ${PAGER:-less} "

		printf %s ' ; rm -f "$tmp" '

		[ ! "$needsterminal" ] && printf %s ' ) & '

		break
	done < "$MAILCAP"
)}

cmd=$(select_command)
if [ "$cmd" ]; then
	eval "$cmd"
else
	exit 1
fi

rm -f "$MAILCAP"
